#!/usr/bin/env node

import { mkdirSync, writeFileSync } from 'fs'
import * as meow from 'meow'
import { EOL } from 'os'
import { join } from 'path'
import { ISDL } from 'prisma-datamodel'
import {
  findDatamodelAndComputeSchema,
  findRootDirectory,
  getImportPathRelativeToOutput,
  getPrismaClientDir,
  readPrismaYml,
} from './config'
const version = require('../package.json').version

const cli = meow(
  `
    nexus-prisma-generate prisma-client-dir output

    > Generate the building blocks for nexus-prisma

    -----
    
    Inputs should be relative to the root of your project

    --output (required): Path to directory where you want to output the typings (eg: ./generated/nexus-prisma)
    --client (optional): Path to your prisma-client directory (eg: ./generated/prisma-client/)
    --js     (optional): Whether to generate the types for Javascript
`,
  {
    flags: {
      client: {
        type: 'string',
      },
      output: {
        type: 'string',
      },
      js: {
        type: 'boolean',
        default: false,
      },
    },
  },
)

main(cli)
function resolveDirective(
  datamodel: ISDL,
  prismaClientPath: string,
  exportString: string,
) {
  return `\
/**
 * This file was automatically generated by custom-prisma-generate@${version}
 * Do not make changes to this file directly
 */

import { prismaObjectType, prismaInputObjectType } from 'nexus-prisma'
import * as prisma from '${prismaClientPath}'

 ${exportString} {
${datamodel.types
  .filter(table => table.directives.length > 0)
  .map(
    type =>
      `    ${type.name}_${type.directives.map(
        d => `${d.name}_${d.arguments['value']}`,
      )}: [${type.fields
        .filter(field => field.directives.length > 0)
        .map(
          field =>
            `'${field.name}-${field.directives.map(
              d => `${d.name}-${d.arguments['value']}`,
            )}'`,
        )
        .join(', ')}]`,
  )
  .join(',' + EOL)}
  }
    `
}
function main(cli: meow.Result) {
  const { client: prismaClientDir, output, js: jsMode } = cli.flags

  if (!output) {
    console.log('ERROR: Missing argument --output')
    process.exit(1)
  }

  const prisma = readPrismaYml()
  const rootPath = findRootDirectory()
  const resolvedOutput = output.startsWith('/')
    ? output
    : join(rootPath, output)
  const resolvedPrismaClientDir = getPrismaClientDir(
    prismaClientDir,
    prisma,
    rootPath,
  )
  const nexusPrismaTypesPath = join(rootPath, output, 'nexus-prisma.ts')
  try {
    // Create the output directories if needed (mkdir -p)
    mkdirSync(resolvedOutput, { recursive: true })
  } catch (e) {
    if (e.code !== 'EEXIST') throw e
  }

  const { datamodel } = findDatamodelAndComputeSchema(
    prisma.configPath,
    prisma.config,
  )

  try {
    //datamodel
    const directive = resolveDirective(
      datamodel,
      getImportPathRelativeToOutput(
        resolvedPrismaClientDir,
        nexusPrismaTypesPath,
      ),
      jsMode ? 'module.exports =' : 'export default',
    )

    if (jsMode) {
      const directivePath = join(rootPath, output, 'directive.js')
      writeFileSync(directivePath, directive)
    } else {
      const directivePath = join(rootPath, output, 'directive.ts')
      writeFileSync(directivePath, directive)
    }
    console.log(`Types generated at ${output}`)
  } catch (e) {
    console.error(e)
  }
}
